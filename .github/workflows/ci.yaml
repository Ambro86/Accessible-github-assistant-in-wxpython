name: Build AssistenteGit Multi-OS

on:
  workflow_dispatch: # Permette l'avvio manuale dalla tab Azioni di GitHub
  push:
    branches: [ master, main ] # Esegue su push nei branch master e main

jobs:
  build:
    name: Build for ${{ matrix.os_name }}
    runs-on: ${{ matrix.os_runner }}
    strategy:
      fail-fast: false # Continua con gli altri OS anche se uno fallisce
      matrix:
        include:
          - os_name: Windows
            os_runner: windows-latest
            asset_name_suffix: .exe
            pyinstaller_add_data_sep: ";"
          - os_name: Linux
            os_runner: ubuntu-latest 
            asset_name_suffix: ""
            pyinstaller_add_data_sep: ":"
          - os_name: macOS-Intel
            os_runner: macos-13
            asset_name_suffix: "" 
            pyinstaller_add_data_sep: ":"
            dmg_name: "AssistenteGit-macOS-Intel.dmg"
          - os_name: macOS-AppleSilicon
            os_runner: macos-latest
            asset_name_suffix: "" 
            pyinstaller_add_data_sep: ":"
            dmg_name: "AssistenteGit-macOS-AppleSilicon.dmg"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      id: setup_python # Aggiunto un id per referenziare l'output della versione Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.13' 

    - name: Get pip cache directory
      id: pip_cache # id per referenziare l'output
      shell: bash
      run: |
        echo "dir=$(pip cache dir)" >> $GITHUB_OUTPUT
        # Stampa il percorso per debug
        echo "Pip cache directory is: $(pip cache dir)"

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ${{ steps.pip_cache.outputs.dir }}
        # Chiave della cache: OS, versione Python installata, un identificatore per i pacchetti principali e una versione manuale della cache
        key: ${{ runner.os }}-pip-${{ steps.setup_python.outputs.python-version }}-wxpython-pyinstaller-crypto-v3
        restore-keys: |
          ${{ runner.os }}-pip-${{ steps.setup_python.outputs.python-version }}-wxpython-pyinstaller-crypto-
          ${{ runner.os }}-pip-${{ steps.setup_python.outputs.python-version }}-wxpython-pyinstaller-

    - name: Install Linux system dependencies for wxPython
      if: matrix.os_runner == 'ubuntu-latest'
      run: |
        sudo apt-get update -qq
        echo "Attempting to install WebKitGTK development libraries..."
        # Prova con libwebkit2gtk-4.1-dev. Se non usi wx.html2.WebView, puoi commentare/rimuovere.
        sudo apt-get install -y --no-install-recommends libwebkit2gtk-4.1-dev || echo "WebKitGTK dev package installation failed or was skipped, continuing..."
        
        echo "Installing other core wxPython dependencies..."
        sudo apt-get install -y --no-install-recommends \
          build-essential \
          pkg-config \
          libgtk-3-dev \
          libglib2.0-dev \
          libpango1.0-dev \
          libcairo2-dev \
          libgdk-pixbuf2.0-dev \
          libatk1.0-dev

    - name: Verify GTK3 installation with pkg-config (Linux)
      if: matrix.os_runner == 'ubuntu-latest'
      run: |
        echo "Verifying GTK+ 3.0 installation via pkg-config..."
        if pkg-config --exists --print-errors "gtk+-3.0 >= 3.0.0"; then
          echo "GTK+ 3.0 found by pkg-config."
          echo "GTK+ 3.0 Version: $(pkg-config --modversion gtk+-3.0)"
        else
          echo "WARNING: GTK+ 3.0 (gtk+-3.0.pc) not found by pkg-config. This might cause issues if wxPython needs to compile from source and GTK3 is a hard requirement not met."
        fi

    - name: Install Python dependencies
      shell: bash 
      run: |
        python -m pip install --upgrade pip setuptools wheel
        echo "Installing wxPython..."
        pip install --verbose wxPython  # --verbose per output dettagliato
        echo "Installing Nuitka..."
        pip install nuitka
        echo "Installing PyInstaller..."
        pip install pyinstaller
        echo "Installing core dependencies..."
        pip install requests urllib3 certifi cryptography
        echo "Installing synthizer3d for audio support..."
        pip install synthizer3d
        echo "All Python dependencies installed successfully."

    - name: Install Windows-specific dependencies  
      if: matrix.os_runner == 'windows-latest'
      shell: bash
      run: |
        echo "Verifying Windows-specific modules..."
        # winsound Ã¨ built-in su Windows, verifichiamo che sia disponibile
        python -c "import winsound; print('winsound module available on Windows')" || echo "Warning: winsound not available"
        echo "Windows-specific dependencies verified."

    - name: Create Python module with Nuitka
      shell: bash
      run: |
        echo "Building Python modules with Nuitka..."
        
        # Crea una copia del file principale con nome compatibile
        echo "Creating Nuitka-compatible copy of main file..."
        cp assistente-git.py assistente_git_main.py
        
        # Compila il modulo principale
        echo "Compiling assistente_git_main.py as module..."
        python -m nuitka --module --include-data-dir=locales=locales --include-data-file=beep.wav=beep.wav --include-data-file=failed.mp3=failed.mp3 --include-data-file=success.mp3=success.mp3 assistente_git_main.py
        
        # Compila moduli ausiliari
        echo "Compiling sound.py module..."
        python -m nuitka --module sound.py
        
        echo "Compiling utils.py module..."
        python -m nuitka --module utils.py
        
        echo "Nuitka module compilation completed."
        
        # Mostra i file generati
        echo "Generated Nuitka modules:"
        ls -la *.so *.pyd *.dylib 2>/dev/null || echo "No compiled modules found with expected extensions"
        find . -name "*.so" -o -name "*.pyd" -o -name "*.dylib" -o -name "*.dist" | head -10

    - name: Create wrapper for PyInstaller
      shell: bash
      run: |
        echo "Creating wrapper file for PyInstaller..."
        echo "#!/usr/bin/env python3" > main_wrapper.py
        echo "# -*- coding: utf-8 -*-" >> main_wrapper.py
        echo "\"\"\"Wrapper file for PyInstaller that imports the Nuitka-compiled module\"\"\"" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "import sys" >> main_wrapper.py
        echo "import os" >> main_wrapper.py
        echo "import traceback" >> main_wrapper.py
        echo "import time" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "def main():" >> main_wrapper.py
        echo "    \"\"\"Main wrapper function\"\"\"" >> main_wrapper.py
        echo "    print('=== AssistenteGit Wrapper Starting ===')" >> main_wrapper.py
        echo "    print(f'Python version: {sys.version}')" >> main_wrapper.py
        echo "    print(f'Working directory: {os.getcwd()}')" >> main_wrapper.py
        echo "    print(f'Executable path: {sys.executable}')" >> main_wrapper.py
        echo "    print(f'Script path: {os.path.abspath(__file__)}')" >> main_wrapper.py
        echo "    print(f'Args: {sys.argv}')" >> main_wrapper.py
        echo "    print(f'Python path: {sys.path}')" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    # Check if we're in PyInstaller bundle" >> main_wrapper.py
        echo "    if hasattr(sys, '_MEIPASS'):" >> main_wrapper.py
        echo "        print(f'PyInstaller bundle detected: {sys._MEIPASS}')" >> main_wrapper.py
        echo "        bundle_dir = sys._MEIPASS" >> main_wrapper.py
        echo "    else:" >> main_wrapper.py
        echo "        print('Running from source directory')" >> main_wrapper.py
        echo "        bundle_dir = os.path.dirname(os.path.abspath(__file__))" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    # Skip detailed file listing - go straight to .pyd check" >> main_wrapper.py
        echo "    print(f'Bundle directory: {bundle_dir}')" >> main_wrapper.py
        echo "    try:" >> main_wrapper.py
        echo "        files = os.listdir(bundle_dir)" >> main_wrapper.py
        echo "        print(f'Total files in bundle: {len(files)}')" >> main_wrapper.py
        echo "    except Exception as e:" >> main_wrapper.py
        echo "        print(f'Error accessing bundle directory: {e}')" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    # Add bundle directory to Python path" >> main_wrapper.py
        echo "    if bundle_dir not in sys.path:" >> main_wrapper.py
        echo "        sys.path.insert(0, bundle_dir)" >> main_wrapper.py
        echo "        print(f'Added {bundle_dir} to Python path')" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    # Try to import Nuitka compiled module first" >> main_wrapper.py
        echo "    print('\\n=== Attempting Nuitka Import ===')" >> main_wrapper.py
        echo "    try:" >> main_wrapper.py
        echo "        print('Checking for assistente_git_main.cp313-win_amd64.pyd...')" >> main_wrapper.py
        echo "        pyd_files = [f for f in os.listdir(bundle_dir) if f.endswith('.pyd')]" >> main_wrapper.py
        echo "        print(f'Found .pyd files: {pyd_files}')" >> main_wrapper.py
        echo "        print('Attempting import of assistente_git_main...')" >> main_wrapper.py
        echo "        import assistente_git_main" >> main_wrapper.py
        echo "        print('SUCCESS: Imported Nuitka-compiled module!')" >> main_wrapper.py
        echo "        print('Checking if module has main functionality...')" >> main_wrapper.py
        echo "        if hasattr(assistente_git_main, '__file__'):" >> main_wrapper.py
        echo "            print(f'Module file: {assistente_git_main.__file__}')" >> main_wrapper.py
        echo "        print('Nuitka module import completed successfully!')" >> main_wrapper.py
        echo "        return" >> main_wrapper.py
        echo "    except Exception as e:" >> main_wrapper.py
        echo "        print(f'FAILED: Nuitka import error: {type(e).__name__}: {e}')" >> main_wrapper.py
        echo "        traceback.print_exc()" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    # Fallback to source file execution" >> main_wrapper.py
        echo "    print('\\n=== Fallback to Source File ===')" >> main_wrapper.py
        echo "    source_file = os.path.join(bundle_dir, 'assistente-git.py')" >> main_wrapper.py
        echo "    if not os.path.exists(source_file):" >> main_wrapper.py
        echo "        source_file = 'assistente-git.py'  # Try current directory" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    print(f'Looking for source file: {source_file}')" >> main_wrapper.py
        echo "    if os.path.exists(source_file):" >> main_wrapper.py
        echo "        print(f'Found source file: {source_file}')" >> main_wrapper.py
        echo "        try:" >> main_wrapper.py
        echo "            print('Reading and executing source file...')" >> main_wrapper.py
        echo "            with open(source_file, 'r', encoding='utf-8') as f:" >> main_wrapper.py
        echo "                source_code = f.read()" >> main_wrapper.py
        echo "            print(f'Source file read successfully ({len(source_code)} characters)')" >> main_wrapper.py
        echo "            exec(source_code, {'__file__': source_file})" >> main_wrapper.py
        echo "            print('SUCCESS: Source file executed!')" >> main_wrapper.py
        echo "            return" >> main_wrapper.py
        echo "        except Exception as exec_error:" >> main_wrapper.py
        echo "            print(f'FAILED: Source execution error: {type(exec_error).__name__}: {exec_error}')" >> main_wrapper.py
        echo "            traceback.print_exc()" >> main_wrapper.py
        echo "    else:" >> main_wrapper.py
        echo "        print(f'ERROR: Source file not found: {source_file}')" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "    print('\\n=== ALL METHODS FAILED ===')" >> main_wrapper.py
        echo "    print('Neither Nuitka module nor source file could be executed.')" >> main_wrapper.py
        echo "    input('Press Enter to exit...')" >> main_wrapper.py
        echo "    sys.exit(1)" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "if __name__ == '__main__':" >> main_wrapper.py
        echo "    try:" >> main_wrapper.py
        echo "        main()" >> main_wrapper.py
        echo "    except KeyboardInterrupt:" >> main_wrapper.py
        echo "        print('\\nInterrupted by user')" >> main_wrapper.py
        echo "        sys.exit(0)" >> main_wrapper.py
        echo "    except Exception as e:" >> main_wrapper.py
        echo "        print(f'\\nUnexpected error in wrapper: {type(e).__name__}: {e}')" >> main_wrapper.py
        echo "        traceback.print_exc()" >> main_wrapper.py
        echo "        input('Press Enter to exit...')" >> main_wrapper.py
        echo "        sys.exit(1)" >> main_wrapper.py
        
        echo "Wrapper file created successfully"
        cat main_wrapper.py

    - name: Build executable with PyInstaller
      shell: bash 
      run: |
        echo "Starting PyInstaller build..."
        
        if [[ "${{ matrix.os_name }}" == *"macOS"* ]]; then
          echo "Building macOS .app bundle with Nuitka-compiled modules..."
          pyinstaller --windowed \
            --add-data "locales${{ matrix.pyinstaller_add_data_sep }}locales" \
            --add-data "beep.wav${{ matrix.pyinstaller_add_data_sep }}." \
            --add-data "failed.mp3${{ matrix.pyinstaller_add_data_sep }}." \
            --add-data "success.mp3${{ matrix.pyinstaller_add_data_sep }}." \
            --additional-hooks-dir=. \
            --hidden-import=sound \
            --hidden-import=utils \
            --hidden-import=assistente_git_main \
            --name AssistenteGit \
            main_wrapper.py
        else
          echo "Building single executable for ${{ matrix.os_name }} with Nuitka-compiled modules..."
          if [[ "${{ matrix.os_name }}" == "Windows" ]]; then
            # Windows: Keep console for debugging
            pyinstaller --onefile --windowed \
              --add-data "locales${{ matrix.pyinstaller_add_data_sep }}locales" \
              --add-data "beep.wav${{ matrix.pyinstaller_add_data_sep }}." \
              --add-data "failed.mp3${{ matrix.pyinstaller_add_data_sep }}." \
              --add-data "success.mp3${{ matrix.pyinstaller_add_data_sep }}." \
              --additional-hooks-dir=. \
              --hidden-import=sound \
              --hidden-import=utils \
              --hidden-import=assistente_git_main \
              --name AssistenteGit \
              main_wrapper.py
          else
            # Linux: Standard build
            pyinstaller --onefile --windowed --noconsole \
              --add-data "locales${{ matrix.pyinstaller_add_data_sep }}locales" \
              --add-data "beep.wav${{ matrix.pyinstaller_add_data_sep }}." \
              --add-data "failed.mp3${{ matrix.pyinstaller_add_data_sep }}." \
              --add-data "success.mp3${{ matrix.pyinstaller_add_data_sep }}." \
              --additional-hooks-dir=. \
              --hidden-import=sound \
              --hidden-import=utils \
              --hidden-import=assistente_git_main \
              --name AssistenteGit \
              main_wrapper.py
          fi
        fi
        
        echo "PyInstaller build finished."

    - name: Test executable
      shell: bash
      run: |
        echo "Testing compiled executable..."
        
        if [[ "${{ matrix.os_name }}" == *"macOS"* ]]; then
          echo "Testing macOS .app bundle..."
          # Basic test that executable starts without immediate crash (macOS doesn't have timeout)
          ./dist/AssistenteGit.app/Contents/MacOS/AssistenteGit --audio-mode --audio-file success.mp3 --volume 0.1 2>&1 | head -10 &
          TEST_PID=$!
          sleep 5
          kill $TEST_PID 2>/dev/null || echo "App test process already finished"
          echo "macOS app test completed"
        elif [[ "${{ matrix.os_name }}" == "Windows" ]]; then
          echo "Testing Windows executable..."
          # Basic test that executable starts without immediate crash (Windows doesn't always handle timeout well)
          ./dist/AssistenteGit.exe --audio-mode --audio-file success.mp3 --volume 0.1 2>&1 | head -10 &
          TEST_PID=$!
          sleep 5
          kill $TEST_PID 2>/dev/null || echo "Windows exe test process already finished"
          echo "Windows exe test completed"
        else
          echo "Testing Linux executable..."
          # Basic test that executable starts without immediate crash
          timeout 5s ./dist/AssistenteGit --audio-mode --audio-file success.mp3 --volume 0.1 2>&1 | head -10 || echo "Binary started (timeout expected)"
          echo "Linux binary test completed"
        fi
        
        echo "Executable test phase completed."

    - name: Create macOS DMG (macOS only)
      if: contains(matrix.os_name, 'macOS')
      shell: bash
      run: |
        echo "Creating DMG for macOS..."
        
        # Rimuovi cartella dmg_temp se esiste
        rm -rf dmg_temp
        
        # Crea una cartella temporanea per il DMG
        mkdir -p dmg_temp
        
        # Termina eventuali processi rimasti
        pkill -f "AssistenteGit" 2>/dev/null || true
        
        # Attendi un po' per assicurarsi che i processi siano terminati
        sleep 3
        
        # Copia l'app nella cartella temporanea
        cp -R dist/AssistenteGit.app dmg_temp/
        
        # Crea un link simbolico alle Applicazioni
        ln -s /Applications dmg_temp/Applications
        
        # Attendi un altro po'
        sleep 2
        
        # Crea il DMG con nome specifico per architettura
        DMG_NAME="${{ matrix.dmg_name }}"
        echo "Creating DMG: $DMG_NAME"
        
        # Usa parametri piÃ¹ specifici per hdiutil
        hdiutil create -volname "AssistenteGit" -srcfolder dmg_temp -ov -format UDZO -fs HFS+ "$DMG_NAME"
        
        echo "DMG created successfully: $DMG_NAME"
        
        # Verifica che il DMG sia stato creato
        ls -la "$DMG_NAME"
    - name: Upload application artifact
      uses: actions/upload-artifact@v4
      with:
        name: AssistenteGit-${{ matrix.os_name }} 
        path: |
          ${{ contains(matrix.os_name, 'macOS') && matrix.dmg_name || format('dist/AssistenteGit{0}', matrix.asset_name_suffix) }}
        if-no-files-found: error