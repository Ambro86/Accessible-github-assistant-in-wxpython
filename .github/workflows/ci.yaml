name: Build AssistenteGit Multi-OS

on:
  workflow_dispatch: # Permette l'avvio manuale dalla tab Azioni di GitHub
  push:
    branches: [ master, main ] # Esegue su push nei branch master e main

jobs:
  build:
    name: Build for ${{ matrix.os_name }}
    runs-on: ${{ matrix.os_runner }}
    strategy:
      fail-fast: false # Continua con gli altri OS anche se uno fallisce
      matrix:
        include:
          - os_name: Windows
            os_runner: windows-latest
            asset_name_suffix: .exe
            pyinstaller_add_data_sep: ";"
          - os_name: Linux
            os_runner: ubuntu-latest 
            asset_name_suffix: ""
            pyinstaller_add_data_sep: ":"
          - os_name: macOS-Intel
            os_runner: macos-13
            asset_name_suffix: "" 
            pyinstaller_add_data_sep: ":"
            dmg_name: "AssistenteGit-macOS-Intel.dmg"
          - os_name: macOS-AppleSilicon
            os_runner: macos-latest
            asset_name_suffix: "" 
            pyinstaller_add_data_sep: ":"
            dmg_name: "AssistenteGit-macOS-AppleSilicon.dmg"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      id: setup_python # Aggiunto un id per referenziare l'output della versione Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.13' 

    - name: Get pip cache directory
      id: pip_cache # id per referenziare l'output
      shell: bash
      run: |
        echo "dir=$(pip cache dir)" >> $GITHUB_OUTPUT
        # Stampa il percorso per debug
        echo "Pip cache directory is: $(pip cache dir)"

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ${{ steps.pip_cache.outputs.dir }}
        # Chiave della cache: OS, versione Python installata, un identificatore per i pacchetti principali e una versione manuale della cache
        key: ${{ runner.os }}-pip-${{ steps.setup_python.outputs.python-version }}-wxpython-pyinstaller-crypto-v3
        restore-keys: |
          ${{ runner.os }}-pip-${{ steps.setup_python.outputs.python-version }}-wxpython-pyinstaller-crypto-
          ${{ runner.os }}-pip-${{ steps.setup_python.outputs.python-version }}-wxpython-pyinstaller-

    - name: Install Linux system dependencies for wxPython
      if: matrix.os_runner == 'ubuntu-latest'
      run: |
        sudo apt-get update -qq
        echo "Attempting to install WebKitGTK development libraries..."
        # Prova con libwebkit2gtk-4.1-dev. Se non usi wx.html2.WebView, puoi commentare/rimuovere.
        sudo apt-get install -y --no-install-recommends libwebkit2gtk-4.1-dev || echo "WebKitGTK dev package installation failed or was skipped, continuing..."
        
        echo "Installing other core wxPython dependencies..."
        sudo apt-get install -y --no-install-recommends \
          build-essential \
          pkg-config \
          libgtk-3-dev \
          libglib2.0-dev \
          libpango1.0-dev \
          libcairo2-dev \
          libgdk-pixbuf2.0-dev \
          libatk1.0-dev

    - name: Verify GTK3 installation with pkg-config (Linux)
      if: matrix.os_runner == 'ubuntu-latest'
      run: |
        echo "Verifying GTK+ 3.0 installation via pkg-config..."
        if pkg-config --exists --print-errors "gtk+-3.0 >= 3.0.0"; then
          echo "GTK+ 3.0 found by pkg-config."
          echo "GTK+ 3.0 Version: $(pkg-config --modversion gtk+-3.0)"
        else
          echo "WARNING: GTK+ 3.0 (gtk+-3.0.pc) not found by pkg-config. This might cause issues if wxPython needs to compile from source and GTK3 is a hard requirement not met."
        fi

    - name: Install Python dependencies
      shell: bash 
      run: |
        python -m pip install --upgrade pip setuptools wheel
        echo "Installing wxPython..."
        pip install --verbose wxPython  # --verbose per output dettagliato
        echo "Installing Nuitka..."
        pip install nuitka
        echo "Installing PyInstaller..."
        pip install pyinstaller
        echo "Installing core dependencies..."
        pip install requests urllib3 certifi cryptography
        echo "Installing synthizer3d for audio support..."
        pip install synthizer3d
        echo "All Python dependencies installed successfully."

    - name: Install Windows-specific dependencies  
      if: matrix.os_runner == 'windows-latest'
      shell: bash
      run: |
        echo "Verifying Windows-specific modules..."
        # winsound è built-in su Windows, verifichiamo che sia disponibile
        python -c "import winsound; print('winsound module available on Windows')" || echo "Warning: winsound not available"
        echo "Windows-specific dependencies verified."

    - name: Create Python module with Nuitka
      shell: bash
      run: |
        echo "Building Python modules with Nuitka..."
        
        # Crea una copia del file principale con nome compatibile
        echo "Creating Nuitka-compatible copy of main file..."
        cp assistente-git.py assistente_git_main.py
        
        # Compila il modulo principale
        echo "Compiling assistente_git_main.py as module..."
        python -m nuitka --module --include-data-dir=locales=locales --include-data-file=beep.wav=beep.wav --include-data-file=failed.mp3=failed.mp3 --include-data-file=success.mp3=success.mp3 assistente_git_main.py
        
        # Compila moduli ausiliari
        echo "Compiling sound.py module..."
        python -m nuitka --module sound.py
        
        echo "Compiling utils.py module..."
        python -m nuitka --module utils.py
        
        echo "Nuitka module compilation completed."
        
        # Mostra i file generati
        echo "Generated Nuitka modules:"
        ls -la *.so *.pyd *.dylib 2>/dev/null || echo "No compiled modules found with expected extensions"
        find . -name "*.so" -o -name "*.pyd" -o -name "*.dylib" -o -name "*.dist" | head -10

    - name: Create wrapper for PyInstaller
      shell: bash
      run: |
        echo "Creating wrapper file for PyInstaller..."
        echo "# Wrapper file for PyInstaller that imports the Nuitka-compiled module" > main_wrapper.py
        echo "import sys" >> main_wrapper.py
        echo "import os" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "# Add current directory to Python path to find compiled modules" >> main_wrapper.py
        echo "sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))" >> main_wrapper.py
        echo "" >> main_wrapper.py
        echo "try:" >> main_wrapper.py
        echo "    # Try to import the Nuitka-compiled module" >> main_wrapper.py
        echo "    import assistente_git_main" >> main_wrapper.py
        echo "    print('Successfully imported Nuitka-compiled assistente_git_main module')" >> main_wrapper.py
        echo "except ImportError as e:" >> main_wrapper.py
        echo "    print(f'Could not import Nuitka module, falling back to source: {e}')" >> main_wrapper.py
        echo "    # Fallback to original source file" >> main_wrapper.py
        echo "    exec(open('assistente-git.py').read())" >> main_wrapper.py
        
        echo "Wrapper file created successfully"
        cat main_wrapper.py

    - name: Build executable with PyInstaller
      shell: bash 
      run: |
        echo "Starting PyInstaller build..."
        
        if [[ "${{ matrix.os_name }}" == *"macOS"* ]]; then
          echo "Building macOS .app bundle with Nuitka-compiled modules..."
          pyinstaller --windowed \
            --add-data "locales${{ matrix.pyinstaller_add_data_sep }}locales" \
            --add-data "beep.wav${{ matrix.pyinstaller_add_data_sep }}." \
            --add-data "failed.mp3${{ matrix.pyinstaller_add_data_sep }}." \
            --add-data "success.mp3${{ matrix.pyinstaller_add_data_sep }}." \
            --additional-hooks-dir=. \
            --hidden-import=sound \
            --hidden-import=utils \
            --hidden-import=assistente_git_main \
            --name AssistenteGit \
            main_wrapper.py
        else
          echo "Building single executable for ${{ matrix.os_name }} with Nuitka-compiled modules..."
          pyinstaller --onefile --windowed --noconsole \
            --add-data "locales${{ matrix.pyinstaller_add_data_sep }}locales" \
            --add-data "beep.wav${{ matrix.pyinstaller_add_data_sep }}." \
            --add-data "failed.mp3${{ matrix.pyinstaller_add_data_sep }}." \
            --add-data "success.mp3${{ matrix.pyinstaller_add_data_sep }}." \
            --additional-hooks-dir=. \
            --hidden-import=sound \
            --hidden-import=utils \
            --hidden-import=assistente_git_main \
            --name AssistenteGit \
            main_wrapper.py
        fi
        
        echo "PyInstaller build finished."

    - name: Create macOS DMG (macOS only)
      if: contains(matrix.os_name, 'macOS')
      shell: bash
      run: |
        echo "Creating DMG for macOS..."
        
        # Rimuovi cartella dmg_temp se esiste
        rm -rf dmg_temp
        
        # Crea una cartella temporanea per il DMG
        mkdir -p dmg_temp
        
        # Attendi un po' per assicurarsi che i processi siano terminati
        sleep 2
        
        # Copia l'app nella cartella temporanea
        cp -R dist/AssistenteGit.app dmg_temp/
        
        # Crea un link simbolico alle Applicazioni
        ln -s /Applications dmg_temp/Applications
        
        # Attendi un altro po'
        sleep 1
        
        # Crea il DMG con nome specifico per architettura
        DMG_NAME="${{ matrix.dmg_name }}"
        echo "Creating DMG: $DMG_NAME"
        
        # Usa parametri più specifici per hdiutil
        hdiutil create -volname "AssistenteGit" -srcfolder dmg_temp -ov -format UDZO -fs HFS+ "$DMG_NAME"
        
        echo "DMG created successfully: $DMG_NAME"
        
        # Verifica che il DMG sia stato creato
        ls -la "$DMG_NAME"
    - name: Upload application artifact
      uses: actions/upload-artifact@v4
      with:
        name: AssistenteGit-${{ matrix.os_name }} 
        path: |
          ${{ contains(matrix.os_name, 'macOS') && matrix.dmg_name || format('dist/AssistenteGit{0}', matrix.asset_name_suffix) }}
        if-no-files-found: error